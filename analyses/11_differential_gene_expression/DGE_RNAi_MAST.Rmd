---
title: "Differential gene expression analysis using MAST for the RNAi data"
author: "Nick Hirschm√ºller"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
set.seed(123)
```


## Introduction
Use linear mixed model to do differential gene expression for the conditions, for which we only have a single replicate. 
We follow the approach described by [Zimmerman et al](https://www.nature.com/articles/s41467-021-21038-1).

```{r}
library(Seurat)
library(tidyverse)
library(here)
library(MAST)
library(SingleCellExperiment)
library(scater)


source(here("plot_theme.R"))
source(here("helper_functions.R"))
```


### Coarse celltypes
```{r}
seurat <- readRDS(here("output", "Ctrl_Notch_NotchCphRNAi_integrated_scent.rds"))
DefaultAssay(seurat) <- "RNA"
# -> remove irrelevant celltypes
seurat <- seurat[, !seurat$celltype_manual %in% c("unk", "unk2", "MT", "dEC", "daEC")]

# for this analysis we will aggregate multiple celltypes:

# Progenitors -> EEP, EB, ISC
# EE -> EE
# EC -> aEC, pEC, mEC, Copper, LFC

seurat@meta.data$tmp_celltype <- case_when(
    seurat$celltype_manual %in% c("ISC", "EB") ~ "Progenitor",
    seurat$high_res_annotation == "EEP" ~ "Progenitor",
    grepl("-EE", seurat$high_res_annotation) ~ "EE",
    seurat$celltype_manual %in% c("mEC", "aEC", "pEC", "LFC", "Copper") ~ "EC",
    T ~ seurat$celltype_manual
)


# remove replicates with very low number of cells per celltype
to_remove <- seurat@meta.data %>%
    group_by(tmp_celltype, orig.ident.unique) %>%
    tally() %>%
    filter(n < 20) %>%
    select(tmp_celltype, orig.ident.unique) %>%
    unite("hash", everything()) %>%
    pull(hash)

seurat$tmp_col <- paste(seurat$tmp_celltype, seurat$orig.ident.unique, sep = "_")

seurat <- seurat[, !seurat$tmp_col %in% to_remove]
```


```{r}
sce <- as.SingleCellExperiment(seurat)

# rerun log2 transformation
sce <- scater::logNormCounts(sce)
sca <- SceToSingleCellAssay(sce, class = "SingleCellAssay")


# How to run must was extracted from here:
# https://www.sc-best-practices.org/conditions/differential_gene_expression.html#id21
# and here https://github.com/kdzimm/PseudoreplicationPaper/blob/c3059a3b361e89bde595f222757d04b89f77eb62/Type_1_Error/Type%201%20-%20MAST%20RE.Rmd
MAST_results <- lapply(setNames(unique(sce$tmp_celltype), unique(sce$tmp_celltype)), function(celltype) {
    print(celltype)
    all_conditions <- setdiff(unique(sce$perturbation), "ctrl")
    tmp_sca <- sca[, sca$tmp_celltype == celltype]

    geneFilter <- freq(tmp_sca) > 0.1
    print(str_interp("MAST will be run for ${sum(geneFilter)} genes"))

    tmp_sca <- tmp_sca[geneFilter, ]

    tmp_sca$perturbation <- factor(tmp_sca$perturbation)
    tmp_sca$perturbation <- relevel(tmp_sca$perturbation, "ctrl")

    tmp_sca$batch <- factor(substr(tmp_sca$orig.ident.unique, 1, 4))
    tmp_sca$orig.ident.unique <- factor(tmp_sca$orig.ident.unique)

    # calculate how many genes are "on", i.e. expressed.
    cdr2 <- colSums(assay(tmp_sca) > 0)
    colData(tmp_sca)$ngeneson <- scale(cdr2)


    # Differential expression analysis with random effects.
    formula <- ~ ngeneson + batch + perturbation + (1 | orig.ident.unique)
    zlmCond <- zlm(
        formula = formula,
        sca = tmp_sca,
        exprs_values = "logcounts",
        method = "glmer",
        ebayes = F,
        strictConvergence = F,
        fitArgsD = list(nAGQ = 0)
    )

    per_condition_res <- lapply(setNames(all_conditions, all_conditions), function(condition) {
        print(condition)
        if (celltype == "EE" & condition == "NotchCphRNAi") {
            return(NULL)
        }
        summaryCond <- MAST::summary(zlmCond, doLRT = paste0("perturbation", condition))
        summaryDt <- summaryCond$datatable
        result <- merge(summaryDt[contrast == paste0("perturbation", condition) & component == "H", .(primerid, `Pr(>Chisq)`)], # hurdle P values
            summaryDt[contrast == paste0("perturbation", condition) & component == "logFC", .(primerid, coef, ci.hi, ci.lo)],
            by = "primerid"
        ) # logFC coefficients

        # do multiple testing correction
        result[, FDR := p.adjust(`Pr(>Chisq)`, "fdr")]
        result <- data.frame(result) %>%
            arrange(FDR) %>%
            tidyr::drop_na()
        return(result)
    })
    return(per_condition_res)
})
saveRDS(MAST_results, here("output", "differential_expression", "MAST", "MAST_res_coarse.rds"))
```


### Save the results in a human readable form
```{r}
MAST_results <- readRDS(here("output", "differential_expression", "MAST", "MAST_res_coarse.rds"))

################
# Save Results #
################
for (celltype in names(MAST_results)) {
    for (condition in names(MAST_results[[celltype]])) {
        dir.create(here("output", "differential_expression", "MAST", condition, celltype),
            showWarnings = F, recursive = TRUE
        )
        if (is.null(MAST_results[[celltype]][[condition]])) {
            next
        }
        MAST_results[[celltype]][[condition]] %>%
            select(gene = primerid, logFC = coef, p_adj = FDR) %>%
            arrange(p_adj) %>%
            mutate(
                celltype = !!celltype,
                condition = !!condition
            ) %>%
            data.table::fwrite(.,
                file = here(
                    "output", "differential_expression",
                    "MAST", condition, celltype,
                    str_interp("MAST_diff_expr_${condition}_${celltype}_coarse.tsv")
                ),
                sep = "\t",
                scipen = 50,
                row.names = F
            )
    }
}
```

### Now do the analysis for granular celltype annotation

```{r}
seurat <- readRDS(here("output", "Ctrl_Notch_NotchCphRNAi_integrated_scent.rds"))
DefaultAssay(seurat) <- "RNA"
# -> remove irrelevant celltypes
seurat <- seurat[, !seurat$celltype_manual %in% c("unk", "unk2", "MT", "dEC", "daEC")]

# for this analysis we will aggregate multiple celltypes:

seurat@meta.data$tmp_celltype <- case_when(
    seurat$high_res_annotation == "EEP" ~ "EEP",
    grepl("-EE", seurat$high_res_annotation) ~ "EE",
    seurat$celltype_manual %in% c("mEC", "aEC", "pEC", "LFC", "Copper") ~ "EC",
    T ~ seurat$celltype_manual
)


# remove replicates with very low number of cells per celltype
to_remove <- seurat@meta.data %>%
    group_by(tmp_celltype, orig.ident.unique) %>%
    tally() %>%
    filter(n < 20) %>%
    select(tmp_celltype, orig.ident.unique) %>%
    unite("hash", everything()) %>%
    pull(hash)

to_remove <- c(to_remove, "EEP_TX47_NotchRNAi")
seurat$tmp_col <- paste(seurat$tmp_celltype, seurat$orig.ident.unique, sep = "_")

seurat <- seurat[, !seurat$tmp_col %in% to_remove]
```


```{r}
sce <- as.SingleCellExperiment(seurat)

# rerun log2 transformation
sce <- scater::logNormCounts(sce)
sca <- SceToSingleCellAssay(sce, class = "SingleCellAssay")



# How to run must was extracted from here:
# https://www.sc-best-practices.org/conditions/differential_gene_expression.html#id21
# and here https://github.com/kdzimm/PseudoreplicationPaper/blob/c3059a3b361e89bde595f222757d04b89f77eb62/Type_1_Error/Type%201%20-%20MAST%20RE.Rmd
MAST_results <- lapply(setNames(unique(sce$tmp_celltype), unique(sce$tmp_celltype)), function(celltype) {
    print(celltype)
    all_conditions <- setdiff(unique(sce$perturbation), "ctrl")
    tmp_sca <- sca[, sca$tmp_celltype == celltype]

    geneFilter <- freq(tmp_sca) > 0.1
    print(str_interp("MAST will be run for ${sum(geneFilter)} genes"))

    tmp_sca <- tmp_sca[geneFilter, ]

    tmp_sca$perturbation <- factor(tmp_sca$perturbation)
    tmp_sca$perturbation <- relevel(tmp_sca$perturbation, "ctrl")

    tmp_sca$batch <- factor(substr(tmp_sca$orig.ident.unique, 1, 4))
    tmp_sca$orig.ident.unique <- factor(tmp_sca$orig.ident.unique)

    # calculate how many genes are "on", i.e. expressed.
    cdr2 <- colSums(assay(tmp_sca) > 0)
    colData(tmp_sca)$ngeneson <- scale(cdr2)


    # Differential expression analysis with random effects.
    formula <- ~ ngeneson + batch + perturbation + (1 | orig.ident.unique)
    zlmCond <- zlm(
        formula = formula,
        sca = tmp_sca,
        exprs_values = "logcounts",
        method = "glmer",
        ebayes = F,
        strictConvergence = F,
        fitArgsD = list(nAGQ = 0)
    )

    per_condition_res <- lapply(setNames(all_conditions, all_conditions), function(condition) {
        print(condition)
        if (celltype == "EE" & condition == "NotchCphRNAi") {
            return(NULL)
        }
        summaryCond <- MAST::summary(zlmCond, doLRT = paste0("perturbation", condition))
        summaryDt <- summaryCond$datatable
        result <- merge(summaryDt[contrast == paste0("perturbation", condition) & component == "H", .(primerid, `Pr(>Chisq)`)], # hurdle P values
            summaryDt[contrast == paste0("perturbation", condition) & component == "logFC", .(primerid, coef, ci.hi, ci.lo)],
            by = "primerid"
        ) # logFC coefficients

        # do multiple testing correction
        result[, FDR := p.adjust(`Pr(>Chisq)`, "fdr")]
        result <- data.frame(result) %>%
            arrange(FDR) %>%
            tidyr::drop_na()
        return(result)
    })
    return(per_condition_res)
})
saveRDS(MAST_results, here("output", "differential_expression", "MAST", "MAST_res_granular.rds"))
```


```{r}
MAST_results <- readRDS(here("output", "differential_expression", "MAST", "MAST_res_granular.rds"))

################
# Save Results #
################
for (celltype in names(MAST_results)) {
    for (condition in names(MAST_results[[celltype]])) {
        dir.create(here("output", "differential_expression", "MAST", condition, celltype),
            showWarnings = F, recursive = TRUE
        )
        if (is.null(MAST_results[[celltype]][[condition]])) {
            next
        }
        MAST_results[[celltype]][[condition]] %>%
            select(gene = primerid, logFC = coef, p_adj = FDR) %>%
            arrange(p_adj) %>%
            mutate(
                celltype = !!celltype,
                condition = !!condition
            ) %>%
            data.table::fwrite(.,
                file = here(
                    "output", "differential_expression",
                    "MAST", condition, celltype,
                    str_interp("MAST_diff_expr_${condition}_${celltype}_granular.tsv")
                ),
                sep = "\t",
                scipen = 50,
                row.names = F
            )
    }
}
```


### For the ISC and EEP Population
```{r}
seurat <- readRDS(here("output", "Ctrl_Notch_NotchCphRNAi_integrated_scent.rds"))
DefaultAssay(seurat) <- "RNA"

# we combine ISC and EEPs to progenitor population
seurat <- seurat[, seurat$high_res_annotation %in% c("ISC", "EEP")]
seurat$tmp_celltype <- "Progenitor_ISC_EEP"
```
 
 
```{r}
sce <- as.SingleCellExperiment(seurat)
sce <- scater::logNormCounts(sce)

sca <- SceToSingleCellAssay(sce, class = "SingleCellAssay")


# How to run must was extracted from here:
# https://www.sc-best-practices.org/conditions/differential_gene_expression.html#id21
# and here https://github.com/kdzimm/PseudoreplicationPaper/blob/c3059a3b361e89bde595f222757d04b89f77eb62/Type_1_Error/Type%201%20-%20MAST%20RE.Rmd

options(warn = 1)
MAST_results <- lapply(setNames(unique(sce$tmp_celltype), unique(sce$tmp_celltype)), function(celltype) {
    print(celltype)
    all_conditions <- setdiff(unique(sce$perturbation), "ctrl")
    tmp_sca <- sca[, sca$tmp_celltype == celltype]

    geneFilter <- freq(tmp_sca) > 0.1
    print(str_interp("MAST will be run for ${sum(geneFilter)} genes"))

    tmp_sca <- tmp_sca[geneFilter, ]

    tmp_sca$perturbation <- factor(tmp_sca$perturbation)
    tmp_sca$perturbation <- relevel(tmp_sca$perturbation, "ctrl")

    tmp_sca$batch <- factor(substr(tmp_sca$orig.ident.unique, 1, 4))
    tmp_sca$orig.ident.unique <- factor(tmp_sca$orig.ident.unique)

    cdr2 <- colSums(assay(tmp_sca) > 0)
    colData(tmp_sca)$ngeneson <- scale(cdr2)


    # Differential expression analysis with random effects.
    # we include batch as fixed effect.
    # Your intuition about including a random intercept for each donor is correct in that it helps adjust for variations
    # unique to each donor, which might capture some of the batch effects if each batch correlates highly with specific
    # donors. However, this assumption may not hold if batch effects are independent of donor variability or if there are
    # batch-specific effects that are not donor-specific.

    formula <- ~ ngeneson + batch + perturbation + (1 | orig.ident.unique)
    zlmCond <- zlm(
        formula = formula,
        sca = tmp_sca,
        exprs_values = "logcounts",
        method = "glmer",
        ebayes = F,
        strictConvergence = F,
        fitArgsD = list(nAGQ = 0)
    )

    per_condition_res <- lapply(setNames(all_conditions, all_conditions), function(condition) {
        print(condition)
        if (celltype == "EE" & condition == "NotchCphRNAi") {
            return(NULL)
        }
        summaryCond <- MAST::summary(zlmCond, doLRT = paste0("perturbation", condition))
        summaryDt <- summaryCond$datatable
        result <- merge(summaryDt[contrast == paste0("perturbation", condition) & component == "H", .(primerid, `Pr(>Chisq)`)], # hurdle P values
            summaryDt[contrast == paste0("perturbation", condition) & component == "logFC", .(primerid, coef, ci.hi, ci.lo)],
            by = "primerid"
        ) # logFC coefficients

        # do multiple testing correction
        result[, FDR := p.adjust(`Pr(>Chisq)`, "fdr")]
        result <- data.frame(result) %>%
            arrange(FDR) %>%
            tidyr::drop_na()
        return(result)
    })
    return(per_condition_res)
})
saveRDS(MAST_results, here("output", "differential_expression", "MAST", "MAST_res_ISC_EEP_combined.rds"))
```



```{r}
### Save the results in a human readable form
MAST_results <- readRDS(here("output", "differential_expression", "MAST", "MAST_res_ISC_EEP_combined.rds"))

################
# Save Results #
################
for (celltype in names(MAST_results)) {
    for (condition in names(MAST_results[[celltype]])) {
        dir.create(here("output", "differential_expression", "MAST", condition, celltype),
            showWarnings = F, recursive = TRUE
        )
        if (is.null(MAST_results[[celltype]][[condition]])) {
            next
        }
        MAST_results[[celltype]][[condition]] %>%
            select(gene = primerid, logFC = coef, p_adj = FDR) %>%
            arrange(p_adj) %>%
            mutate(
                celltype = !!celltype,
                condition = !!condition
            ) %>%
            data.table::fwrite(.,
                file = here(
                    "output", "differential_expression",
                    "MAST", condition, celltype,
                    str_interp("MAST_diff_expr_${condition}_${celltype}.tsv")
                ),
                sep = "\t",
                scipen = 50,
                row.names = F
            )
    }
}
```


```{r}
sessionInfo()
```






