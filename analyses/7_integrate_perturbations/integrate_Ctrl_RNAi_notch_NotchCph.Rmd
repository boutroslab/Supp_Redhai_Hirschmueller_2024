---
title: "Integration of the ALL samples"
author: "Nick Hirschm√ºller"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
set.seed(123)
```


```{r load libraries}
library(here)
library(Seurat)
library(tidyverse)
library(patchwork)

# we need this to run phate. this is completely optional and not actually used in the paper (but in the shiny app)
Sys.setenv(RETICULATE_PYTHON = "/g/huber/users/hirschmueller/software/miniconda3/bin/python")
RETICULATE_PYTHON="/g/huber/users/hirschmueller/software/miniconda3/bin/python"
library(reticulate)
library(phateR)


# load custom functions
source(here("plot_theme.R"))
source(here("helper_functions.R"))
```

## Introduction
Integrate the different perturbations using Seurat.

```{r}
# we have to modify the inputs a bit to make sure that no two barcodes overlap. just adding the orig indent (TX47) might not be enough because we have multiple ones
ctrl <- readRDS(here("output", "ctrlRNAi_seurat_integrated_annotated_high_res_cellcycle.rds"))
ctrl$orig.ident.unique <- paste(ctrl$orig.ident, "ctrl", sep = "_")
ctrl <- RenameCells(ctrl, add.cell.id = "ctrl")
ctrl@meta.data$high_res_annotation <- ctrl$celltype_manual


NotchRNAi <- readRDS(here("output", "notchRNAi_seurat_TX47_annotated_high_res_cellcycle.rds"))
NotchRNAi$orig.ident.unique <- paste(NotchRNAi$orig.ident, "NotchRNAi", sep = "_")
NotchRNAi <- RenameCells(NotchRNAi, add.cell.id = "NotchRNAi")

NotchCphRNAi <- readRDS(here("output", "NotchCphRNAi_seurat_TX49_rep1_annotated_cellcycle.rds"))
NotchCphRNAi$orig.ident.unique <- paste(NotchCphRNAi$orig.ident, "NotchCphRNAi", sep = "_")
NotchCphRNAi <- RenameCells(NotchCphRNAi, add.cell.id = "NotchCphRNAi")
# this sample has no high res annotation because not enough EEs. In this case high res annotation is exactly the same as celltype_manual
NotchCphRNAi@meta.data$high_res_annotation <- NotchCphRNAi$celltype_manual

### also load the 3 prime data
ctrl_3prime <- readRDS(here("output", "ctrlKO_seurat_integrated_annotated_high_res_cellcycle_region.rds"))
ctrl_3prime$orig.ident.unique <- paste(ctrl_3prime$orig.ident, "ctrl_3prime", sep = "_")
ctrl_3prime <- RenameCells(ctrl_3prime, add.cell.id = "ctrl_3prime")

notch_3prime <- readRDS(here("output", "notchKO_seurat_integrated_annotated_high_res_cellcycle_region.rds"))
notch_3prime$orig.ident.unique <- paste(notch_3prime$orig.ident, "notch_3prime", sep = "_")
notch_3prime <- RenameCells(notch_3prime, add.cell.id = "notch_3prime")
```


```{r}
# split into individual experiments
ctrl_split <- SplitObject(DietSeurat(ctrl, assays = "RNA"), split.by = "orig.ident.unique")
NotchRNAi_split <- SplitObject(DietSeurat(NotchRNAi, assays = "RNA"), split.by = "orig.ident.unique") # not really necessary since only one sample anyway
NotchCphRNAi_split <- SplitObject(DietSeurat(NotchCphRNAi, assays = "RNA"), split.by = "orig.ident.unique") # not really necessary since only one sample anyway

ctrl_3prime_split <- SplitObject(DietSeurat(ctrl_3prime, assays = "RNA"), split.by = "orig.ident.unique")
notch_3prime_split <- SplitObject(DietSeurat(notch_3prime, assays = "RNA"), split.by = "orig.ident.unique")



# Split and minor preprocessing of each dataset.
ctrl_split <- lapply(ctrl_split, function(x) {
    x$perturbation <- "ctrl"
    x <- NormalizeData(x, normalization.method = "LogNormalize", scale.factor = 10000)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 3000)
    x <- ScaleData(x)
    return(x)
})

NotchRNAi_split <- lapply(NotchRNAi_split, function(x) {
    x$perturbation <- "NotchRNAi"
    x <- NormalizeData(x, normalization.method = "LogNormalize", scale.factor = 10000)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 3000)
    x <- ScaleData(x)
    return(x)
})


NotchCphRNAi_split <- lapply(NotchCphRNAi_split, function(x) {
    x$perturbation <- "NotchCphRNAi"
    x <- NormalizeData(x, normalization.method = "LogNormalize", scale.factor = 10000)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 3000)
    x <- ScaleData(x)
    return(x)
})

ctrl_3prime_split <- lapply(ctrl_3prime_split, function(x) {
    x$perturbation <- "ctrl_3prime"
    x <- NormalizeData(x, normalization.method = "LogNormalize", scale.factor = 10000)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 3000)
    x <- ScaleData(x)
    return(x)
})

notch_3prime_split <- lapply(notch_3prime_split, function(x) {
    x$perturbation <- "notch_3prime"
    x <- NormalizeData(x, normalization.method = "LogNormalize", scale.factor = 10000)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 3000)
    x <- ScaleData(x)
    return(x)
})



# combine all seurat experiments in one list
combined_list <- c(
    ctrl_split, NotchRNAi_split, NotchCphRNAi_split,
    ctrl_3prime_split, notch_3prime_split
)

# check that ALL barcode are unique
stopifnot(sapply(combined_list, function(x){Cells(x)}) %>% length() == sapply(combined_list, function(x){Cells(x)}) %>% n_distinct())

# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = combined_list)

# find anchors between experiments
# use the 3 prime data as anchors so they umap has a similar shape to the KO UMAP
anchors <- FindIntegrationAnchors(
    object.list = combined_list,
    anchor.features = features,
    reference = which(grepl("3prime", names(combined_list)))
)

seurat_naive_integration <- IntegrateData(
    anchorset = anchors,
    dims = 1:15
)


DefaultAssay(seurat_naive_integration) <- "integrated"
seurat_naive_integration <- ScaleData(seurat_naive_integration, verbose = F) %>%
    RunPCA(., npcs = 50, verbose = F) %>%
    RunUMAP(.,
        reduction = "pca",
        dims = 1:20,
        min.dist = 0.5,
        n.neighbors = 45,
        seed.use = 1,
        verbose = FALSE
    ) %>%
    RunTSNE(., reduction = "pca", dims = 1:20, verbose = F) %>%
    FindNeighbors(., dims = 1:20, k.param = 10, verbose = F) %>%
    FindClusters(.,
        resolution = c(0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 1, 1.3, 1.5)
    )

# completely optional, is never actually used in the paper, only in the shiny app.
phate_coords <- phate(Embeddings(seurat_naive_integration, "pca")[, 1:20],
    knn = 5,
    decay = 40,
    npca = NULL
)

seurat_naive_integration[["phate"]] <- CreateDimReducObject(
    embeddings = phate_coords$embedding * 100,
    key = "PHATE",
    assay = "RNA"
)

# now remove the KO samples because they were only used to "guide" the integration.

seurat_wo_KO <- seurat_naive_integration[,!grepl("3prime", seurat_naive_integration$orig.ident.unique)]

saveRDS(seurat_wo_KO, here("output", "Ctrl_Notch_NotchCphRNAi_integrated.rds"))
```

```{r}
sessionInfo()
```








